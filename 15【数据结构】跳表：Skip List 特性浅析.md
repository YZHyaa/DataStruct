## 1.跳表 = 有序链表+多级索引
对于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是 O(n)。下面我们就通过4张图片看看如何从链表转化成跳表：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201005170722555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201005171240306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201005171335972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201005171502131.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center)
到这里相信你也发现了，这种**带多级索引的链表**，就是跳表。
## 2.时间复杂度分析
### 2.1 查询：O(logn)）
按照我们刚才分析的，每两个结点会抽出一个结点作为上一级索引的结点，那第一级索引的结点个数大约就是 n/2，第二级索引的结点个数大约就是 n/4，第三级索引的结点个数大约就 是 n/8，依次类推，也就是说，第 k 级索引的结点个数是第 k-1 级索引的结点个数的 1/2，那第 k级索引结点的个数就是 n/(2^k)。 

假设索引有 h 级，高级的索引有 2 个结点。通过上面的公式，我们可以得到 n/(2^h)=2， 从而求得 h=log n-1。如果包含原始链表这一层，整个跳表的高度就是 log n。我们在跳表中查询某个数据的时候，如果每一层都要遍历 m 个结点，那在跳表中查询一个数据的时间复杂度就是 **O(m*logn)**。（无论几个节点一个索引，等价于只是m改变）

1. 那这个 m 的值是多少呢？这个要根据几个节点抽一个索引来确定，比如上面的每2个节点抽一个索引，那么我们每一级索引都多只需要遍历 3 个 结点，也就是说 m=3
2. 为什么是 3 呢？假设我们要查找的数据是 x
	1. 在第 k 级索引中，我们遍历到 y 结点之后，发现 x 大于 y，小于后面的结点 z，所以我们通过 y 的 down 指针，从第 k 级索引下降到第 k-1 级索引。
	2. 在 第 k-1 级索引中，y 和 z 之间只有 3 个结点（包含 y 和 z），所以，我们在 K-1 级索引中最多只需要遍历 3 个结点，依次类推，每一级索引都多只需要遍历 3 个结点。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201005205509457.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center)

通过上面的分析，我们得到 m=3，所以在跳表中查询任意数据的时间复杂度就是 O(logn)。这个查找的时间复杂度跟二分查找是一样的。换句话说，**跳表其实是基于单链表实现了二分查找**
```
反推法：
f(执行次数++）：若查一次索引，可以查2个节点，查n次索引，则能查2x2x2x2 = 2ⁿ
f(数据规模++)：取反：则在每两个节点一个索引的情况下，增加一个节点只需查logn次
```

### 2.2 插入：O(logn)
我们知道，在单链表中，一旦定位好要插入的位置，插入结点的时间复杂度是很低的，就是 O(1)。但是，这里为了保证原始链表中数据的有序性，我们需要先找到要插入的位置，这个查找操作就会比较耗时。
  * 对于纯粹的单链表，需要遍历每个结点，来找到插入的位置，即O(n)复杂度
  * 对于跳表来说，查找某个结点的的时间复杂度是 O(logn)，所以这里查找某个数据应该插入的位置，方法也是类似的，时间复杂度也是 O(logn)。下面有一张图，你可以很清晰地看到插入的过程。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201005180705306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center)
### 2.3 删除
跳表的删除操作其实也分为两部分：
* 查找：跳表的查找复杂度为 O(logn)
* 删除：这里就要分为是双向链表还是是单链表了。如果是双向链表，那么直接就能获取到前置节点pre，所以时间复杂度就是O(1)；而如果是单链表那么还需要一次遍历才能找到前置节点pre。

这里还要注意一点，如果这个结点在索引中也有出现，我们除了要删除原始链表中的结点，还要删除索引中的。

## 3.空间复杂度分析
假设原始链表大小为 n，每2个节点抽一个，每层索引的节点数：
```
n/2, n/4, n/8,..., 8, 4, 2   ==> 空间复杂度 = n/2 + n/4 + n/8 +...+ 8 + 4 + 2 = n - 2  ==> O(n)
```
假设原始链表大小为n，没3个节点抽一个，每层索引的节点数：
```
n/3, n/9, n/27,..., 9, 3, 1 ==> 空间复杂度 = n/3 + n/9 + n/27 +...+ 9 + 3 + 1 = n/2 ==> O(n)
```
* 通过每三个节点抽象一个索引，虽然空间复杂度都是**O(n)**，但所占用的空间却减少了一半
* 实际上，在软件开发中，我们不必太在意索引占用的额外空间。在学习过程中，我们习惯性地把要处理的数据看成整数，但是在实际的软件开发中，原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值和几个指针，并不需要存储对象，所以当对象 比索引结点大很多时，那索引占用的额外空间就可以忽略了。

## 4.索引动态更新
### 4.1 退化成链表的问题
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201005202527321.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center)
作为一种动态数据结构，我们需要某种手段来维护索引与原始链表大小之间的平衡，也就是说，如果链表中结点多了，索引结点就相应地增加一些，避免复杂度退化，以及查找、插 入、删除操作性能下降。
### 4.2 随机函数更新索引
红黑树、AVL 树这样平衡二叉树，它们是通过左右旋的方式保持左右子树的大小平衡，而跳表是通过随机函数来维护前面提到的“平衡性”。意思是，当我们往跳表中插入数据时，可以选择同时将这个数据插入到部分索引层中。如何选择加入哪些索引层呢？

  我们**通过一个随机函数，来决定将这个结点插入到哪几级索引中**，比如随机函数生成了值 K，那我们就将这个结点添加到第一级到第 K 级这 K 级索引中。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201005205828542.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center)
随机函数的选择很有讲究，从概率上来讲，能够保证跳表的索引大小和数据大小平衡性，不至于性能过度退化。
## 5.跳表应用
### 5.1 redis有序集合
Redis 中的有序集合是通过跳表来实现的，严格点讲，其实还用到了散列表，我们现在暂且忽略这部分。Redis 中的有序集合支持的核心操作主要有下面这几个：

```
插入一个数据；
删除一个数据；
查找一个数据；
按照区间查找数据（比如查找值在 [100, 356] 之间的数据）；
迭代输出有序序列。
```

* 其中，插入、删除、查找以及迭代输出有序序列这几个操作，红黑树也可以完成，时间复杂度跟跳表是一样的。

* 但是，**按照区间来查找数据这个操作，红黑树的效率没有跳表高**。

  对于按照区间查找数据这个操作，跳表可以做到 O(logn) 的时间复杂度定位区间的起点， 然后在原始链表中顺序往后遍历就可以了。这样做非常高效。

当然，Redis 之所以用跳表来实现有序集合，还有其他原因，比如：
1. 跳表更容易代码实现。 虽然跳表的实现也不简单，但比起红黑树来说还是好懂、好写多了，而简单就意味着可读性好，不容易出错。
2. 跳表更加灵活，它可以通过改变索引构建策略，有效平衡执行效率和内存消耗。

### 5.2 跳表与红黑树

虽然跳表有这么的优点，但**跳表也不能完全替代红黑树**。因为红黑树比跳表的出现要早一些，很多编程语言中的 Map 类型都是通过红黑树来实现的。我们做业务开发的时候，直接拿来用就可以了，不用费劲自己去实现一个红黑树，但是跳表并没有一个现成的实现，所以在开发中，如果你想使用跳表，必须要自己实现。
